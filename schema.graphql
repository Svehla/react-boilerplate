schema {
  query: RootQueryType
  mutation: RootMutationType
}

"""
Direct the client to resolve this field locally, either from the cache or local resolvers.
"""
directive @client(
  """
  When true, the client will never use the cache for this value. See
  https://www.apollographql.com/docs/react/essentials/local-state/#forcing-resolvers-with-clientalways-true
  """
  always: Boolean
) on FIELD | FRAGMENT_DEFINITION | INLINE_FRAGMENT

"""
Export this locally resolved field as a variable to be used in the remainder of this query. See
https://www.apollographql.com/docs/react/essentials/local-state/#using-client-fields-as-variables
"""
directive @export(
  """The variable name to export this field as."""
  as: String!
) on FIELD

"""
Specify a custom store key for this result. See
https://www.apollographql.com/docs/react/advanced/caching/#the-connection-directive
"""
directive @connection(
  """Specify the store key."""
  key: String!

  """
  An array of query argument names to include in the generated custom store key.
  """
  filter: [String!]
) on FIELD

type RootQueryType {
  users(pagination: query_users_args_pagination!): connection_query_users_list
  publicUserViewer: PublicUser
  publicUser(id: Int): PublicUser
  isPublicUserLoggedIn: Boolean
  post(id: ID!): Post
  posts(pagination: query_posts_args_pagination!): connection_query_posts_list
  appVersion: String
}

type connection_query_users_list {
  count: Int
  items: [User!]
}

type User {
  id: ID!
  firstName: String
  email: String
  age: Int
  profileImgUrl: String
  role: UserRoleEnum
  isEmailVerified: Boolean
  posts(pagination: user_posts_args_args_pagination!): connection_user_posts_list
}

enum UserRoleEnum {
  Admin
  Editor
}

type connection_user_posts_list {
  count: Int
  items: [Post!]
}

type Post {
  id: ID!
  name: String
  text: String
  authorId: ID
  author: PublicUser
  comments(pagination: post_comments_args_pagination!): connection_post_comments_list
  reactions(pagination: post_reactions_args_pagination!): connection_post_reactions_list
}

type PublicUser {
  id: ID!
  email: String
  loginType: PublicUserLoginTypeEnum
  profileImg: String
  posts(pagination: PublicUser_posts_args_pagination!): connection_PublicUser_posts_list
  reactions(pagination: PublicUser_reactions_args_pagination!): connection_PublicUser_reactions_list
}

enum PublicUserLoginTypeEnum {
  Google
}

type connection_PublicUser_posts_list {
  count: Int
  items: [Post]
}

input PublicUser_posts_args_pagination {
  offset: Int!
  limit: Int!
}

type connection_PublicUser_reactions_list {
  count: Int
  items: [PostReaction!]
}

type PostReaction {
  id: ID!
  reactionType: ReactionTypeEnum
  publicUserId: String
  author: PublicUser
}

enum ReactionTypeEnum {
  Reaction1
  Reaction2
  Reaction3
  Reaction4
}

input PublicUser_reactions_args_pagination {
  offset: Int!
  limit: Int!
}

type connection_post_comments_list {
  count: Int
  items: [Comment]
}

type Comment {
  id: ID!
  text: String
  authorId: ID
  createdAt: String
  updatedAt: String
  author: PublicUser
}

input post_comments_args_pagination {
  offset: Int!
  limit: Int!
}

type connection_post_reactions_list {
  count: Int
  items: [PostReaction!]
}

input post_reactions_args_pagination {
  offset: Int!
  limit: Int!
}

input user_posts_args_args_pagination {
  offset: Int!
  limit: Int!
}

input query_users_args_pagination {
  offset: Int!
  limit: Int!
}

type connection_query_posts_list {
  count: Int
  items: [Post!]
}

input query_posts_args_pagination {
  offset: Int!
  limit: Int!
}

type RootMutationType {
  userLogin(input: user_login_mutation_input_input_arg!): user_login_output
  userRegistrationMutation(input: user_registration_mutation_input_input_arg!): user_registration_output
  verifyUserEmailMutation(input: Verify_user_input_mutation_input_arg!): verify_user_email_output
  publicUserLogoutMutation: String
  addPostMutation(input: addPostMutation_args_input_arg!): addPostMutation_type
  addCommentMutation(input: addCommentMutation_args_input_arg!): addCommentMutation_type
  addPostReactionMutation(input: addPostReactionMutation_args_input_arg!): addPostReactionMutation_type
}

type user_login_output {
  user: User
  token: String
}

input user_login_mutation_input_input_arg {
  email: Email!
  password: Password!
}

"""
The Email scalar type represents E-Mail addresses compliant to RFC 822.
"""
scalar Email

"""A password string. Has to be between 6 and 50 characters long."""
scalar Password

type user_registration_output {
  user: User
  token: String
}

input user_registration_mutation_input_input_arg {
  email: Email!
  password: Password2!
}

"""A password string. Has to be between 3 and 20 characters long."""
scalar Password2

type verify_user_email_output {
  isTokenVerified: Boolean
}

input Verify_user_input_mutation_input_arg {
  verifyToken: String!
}

type addPostMutation_type {
  post: Post
}

input addPostMutation_args_input_arg {
  text: LimitedString
}

"""A limited string. Has to be between 10 and 10000 characters long."""
scalar LimitedString

type addCommentMutation_type {
  comment: Comment
}

input addCommentMutation_args_input_arg {
  text: LimitedString2
  postId: Int!
}

"""A limited string. Has to be between 3 and 10000 characters long."""
scalar LimitedString2

type addPostReactionMutation_type {
  postReaction: PostReaction
}

input addPostReactionMutation_args_input_arg {
  text: LimitedString3
  postId: Int!
  reactionType: ReactionTypeEnum!
}

"""A limited string. Has to be between 3 and 10000 characters long."""
scalar LimitedString3
